#初级班第一节

## 时间复杂度
评价一个算法流程的好坏，先看时间复杂度的指标，然后分析样本数据下的实际运行时间，也就是常数项时间。

常数时间的操作:一个操作如果和数据量没有关系，每次都是固定时间内完成的操作。
例如：数组寻址操作，加减乘除，位运算操作

## 排序算法
### 冒泡排序BubbleSort
时间复杂度O(N^2)，额外空间复杂度O(1)

每一次排序，将最大的放到最后，接下来每次只需要循环遍历到end-1

###插入排序SelectSort
时间复杂度O(N^2)，额外空间复杂度O(1)

两层for循环，外层从第一个数开始遍历，内层从该数后面一个数字开始遍历，在内层中每个数都和当前minIndex比较，取值较小的数的下标为新的minIndex，然后与当前i值交换。

#### 注意
```java
swap(a, b){
a = a + b;
b = a - b;
a = a - b;
}
```

这段代码是没问题的，但是如果是根据数组下标进行交换，则会出现当最终不需要交换但是执行到swap时，出现置0的情况
如：
```java
swap(int[] arr, int i, int j){
arr[i] = arr[i] + arr[j];
arr[j] = arr[i] - arr[j];
arr[i] = arr[i] - arr[j];
```
如果i和j相等，假设为3，则会在第二行出现arr[3]=0,3下标处则直接变为3，没有达到交换到效果。
此种异或方式同样存在问题
```java
swap(int[] arr, int i, int j){
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```
###插入排序InsertSort 
时间复杂度O(N^2)，额外空间复杂度O(1)
最好情况O(N)，最坏情况O(N^2)，当时间复杂度受样本原始状况影响时，一律按最差情况估计。

### 对数器
0. 有一个你想要测的方法a，
1. 实现一个绝对正确但是复杂度不好的方法b，
2. 实现一个随机样本产生器
3. 实现比对的方法
4. 把方法a和方法b比对很多次来验证方法a是否正确。
5. 如果有一个样本使得比对出错，打印样本分析是哪个方法出
错
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经
正确。

###剖析递归行为和递归行为时间复杂度的估算

####一个递归行为的例子 Code002
递归就是将大问题分解为一个一个小问题，其中同时使用到分治的思想

要求：在整个数组中找到最大值

1. 分解小问题，携带分治思想：左边的最大值leftMax，右边的最大值rightMax，这两个中间最大的值，
即为整个数组最大值。从中间分为两部分，分别求出左右最大值，比较二者
2. 左边和右边又可以继续分为两部分，直到“终止条件（递归调用中必然需要终止条件）”
，只有一个数的时候，不可以再分为两部分，即l == r的时候。

master公式的使用:用来估计递归行为时间复杂度

T(N) = a*T(n/b) + O(n^d)

T(N):样本量为N的时候算法时间复杂度

a：将总的样本规模分解后，子规模的执行次数

n/b：每个子规模中的样本个数。n个样本被分为b个子样本进行求解。
1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)

master公式只适用于子问题规模相等的情况，并且使用master公式时，
只需要从代码层面看将总的问题分为了几个子问题，而不用考虑子问题继续分解为子问题


代入Code002

T(N) = 2*(n/2) + O(1),即为T(N) = 2*(n/2) + O(n^0);
所以Code002的时间复杂度为O(n *log(1,1)) = O(n)

###MergeSort归并排序
时间复杂度O(N*logN)，额外空间复杂度O(N)

T(N) = 2*(n/2) + O(N),即为T(N) = 2*(n/2) + O(n^1);

所以归并排序时间复杂度为O(n ^ 1 *log(1,1)) = O(n * logn)



### 小和问题 Code003
在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组
的小和。

例子：

[1,3,4,2,5]

1左边比1小的数，没有；

3左边比3小的数，1；

4左边比4小的数，1、3；

2左边比2小的数，1；

5左边比5小的数，1、3、4、2；

所以小和为1+1+3+1+1+3+4+2=16

使用归并排序的思想，在每次merge的过程中将sum累加起来，即为结果。

### 逆序对 Code004
在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

仍然利用归并排序的思想，在merge的过程中，比较左右数的大小，满足题意则打印。

### 快速排序QuickSort
时间复杂度O(N*logN)，额外空间复杂度O(logN)

经典快排：选择一个数字，例如第一个数为n，以n为中间点将小于等于n的全部放在n的左边
大于n的全部放在n的右边，假设此时n在index处，之后递归排序左边0到index-1数组，和右边
index+1到arr.length-1数组，直到子数组长度为1，即只剩下一个数，停止排序，返回上层。
这种方法，一次只解决了一个特定中枢位置的排序

改进后的快排，随机选择一个index，打乱原始数据状况。并且将小于的放左边，等于的放中间，大于的放右边，
如果存在多个等值数字，一次排序可以解决多个特定中枢位置。
####引子1 AND 引子2 Code005 
引子1：给定一个数组arr，和一个数num，请把小于等于num的数放在数
   组的左边，大于num的数放在数组的右边。 

假设数组为0到N-1，初始p指向-1，代表小于等于区域，开始遍历数组，
如果当前数小于等于num，当前数与p+1小于等于区域后一位交换，并且小于等于区域向左扩张
一位，即p++，index++ 遍历到下一个数。 如果当前数大于num，不做任何操作，遍历到下一个数。

引子2：荷兰国旗问题。给定一个数组arr，和一个数num，请把小于num的数放在数组的
           左边，等于num的数放在数组的中间，大于num的数放在数组的
           右边。
           
假设数组为0到N-1，初始p指向-1，代表小于区域，p2指向N，代表大于区域。开始遍历数组，
如果当前数小于等于num，当前数与p1+1等于区域后一位交换，并且小于区域向左扩张
一位，即p++， index++ 遍历到下一个数。如果当前数大于num，与p2-1大于区域前一位数交换，并且大于区域向右扩张一位，
即p2--，下一轮循环仍然遍历当前index的数。如果当前数与num相等，index++ 直接遍历下一个数。

### HeapSort 堆排序
时间复杂度O(N*logN)，额外空间复杂度O(1)
堆结构非常重要

1.堆结构的heapInsert与heapify
2.堆结构的增大和减少
3.如果只是建立堆的过程，时间复杂度为O(N)
4.优先级队列结构，就是堆结构
#### 满二叉树和完全二叉树的性质

#### 以一个数组来表示堆结构
index位置的父节点 (index-1) / 2

index位置的左孩子 index * 2 + 1

index位置的右孩子 index * 2 + 2

####大根堆和小根堆
完全二叉树中每一个子树的最大值或者最小值都是子树的头部。

####给定一个数组，可以看做一个完全二叉树，将它变为大根堆。Code006
[2,1,3,6,0,4] -> [6,3,4,1,0,2]

#### 一个水管不断往外吐出数字，要求随时取出这些数字的中位数 Code007

 准备一个大根堆，一个小根堆，大根堆放n / 2个较小的数字，小根堆放 n / 2个较大的数字，
 大根堆的头和小根堆的头则代表最中间两个数字。由此得出中位数。
 当大根堆与小根堆中的节点差超过1时，将大根堆的头放入小根堆或者小根堆的头
 放入大根堆，二者重新调整。
 每次进来一个新的数字，调整的代价是O(logN)，效率非常高。
 
 几乎所有的贪心问题都用到堆结构

### 排序算法的稳定性
原本序列在经过排序之后，相对次序不变，即原本在前的数经过排序之后仍然在前。
这个性质在业务算法中经常用到，按照不同属性对业务数据进行排序，仍然保持上一次排序之后的相对次序。

####常规基于比较O(N * 2)算法

冒泡，插入可以做到稳定。 选择排序不可以。

####常规基于比较O(NlogN)算法

归并排序可以做到稳定。快排不可以，因为partion过程做不到稳定。堆排序不可以，建立根堆的时候，稳定性就被破坏了。

额外空间复杂度O(1)情况下快排

###工程中的综合排序算法

假设一个很长的数组，首先判断数组里面的数据类型。

如果是基础类型数据，int, long , float, double, short,使用快排，因为从业务角度上来看，基础类型不用区分原始序列的顺序，不要求稳定性。

如果是自定义的对象，比如People，Student，使用归并排序。需要稳定性。

如果数组长度很短，在小与60的情况下，不论什么类型，直接使用插入排序。原因在于插排的常数项非常低，数组长度较短的情况下，O(N*2)的劣势表现不明显，但是常数项极低，小样本情况下速度很快。

工程中综合各个排序算法的有点，在一个大样本数据情况下，首先分治递归处理，一旦子问题的数据规模达到插排标准，就进行插排。

###排序问题的一些补充
归并排序的额外空间复杂度可以变成O(1)，但是非常难，可以搜“归并排序 内部缓存法”

快速排序可以做到稳定性问题，但是非常难，可以搜“01 stable sort”，01稳定排序
有一道题目，是奇数放在数组左边，偶数放在数组右边，还
要求原始的相对次序不变。问是否能做到时间复杂度O(N)，额外空间复杂度O(1)。
奇书偶数，大于小于，都是01问题。
这个过程其实就是快排的partion过程，如果这个能够做到，则快排的partion过程能够做到稳定。

面试就是让面试官喜欢上自己的思维

###比较器的使用
实现Comparator接口的compare方法。

返回一个负数，认为第一个参数排在前面

返回一个正数，认为第二个参数排在前面

返回0，认为两个一样大。

即，当需要传入的两个参数从小到大排序时，return o1 - o2

需要传入的两个参数从大到小排序时，return o2 - o1

###桶排序,计数排序，基数排序
非基于比较的排序，与被排序样本的实际数据状况有关系，会由此产生瓶颈，不能做为一个通解被应用到所有方面。 所以实际中并不常用

时间复杂度O(N)， 额外空间复杂度O(N)，具有稳定性。

#### 计数排序。给定一个数组中全是0-10的数字，将它进行排序。Code009
使用计数排序排序，new 一个help数组，遍历一次原数组，在i位置上存储给定数组中值为i的数字出现的次数，再遍历一次help数组，从0位置开始
将每个值重新写入原数组。

当数组中数字范围较大时，则不适用计数排序。如果从0-20亿，准备20亿个桶不现实，此时用到基数排序。

桶是一个容器，一个桶可以是一个数组，也可以是一个链表一个队列一个堆，只要做到容器功能即可。

#### 基数排序。基数排序永远只准备10个桶，按照个位数先排，然后十位数....

#### Code010
给定一个数组，求如果排序之后，相邻两数的最大差值，要求时
间复杂度O(N)，且要求不能用非基于比较的排序。

假设传入数组为arr，遍历得出数组里面的最大值为max，最小值为min。
 使用arr.length + 1个桶，数组里面的最小值放入第一个桶，最大值放入最后一个桶。
，根据公式bid = (num[i] - min) * len / (max - min)得出num[i]应该放在哪一个值范围的桶内。
则最后必然会出现空桶的情况，因为一共arr.length个数，而代码里面根据值的不桶，放入不同的arr.length + 1
个桶内，所以至少会出现一个空桶。两个非空桶之间的最大值与最小值之差，必然大于一个桶内可以表示的范围，求出所以这些差值的最大的一个值，
则是需要的答案。

每一个桶里面装bucketMax，bucketMin，hasNum三个值
分别代表当前桶内的最大值，最小值，是否已经装入数字。

#### 基数排序 Code012

