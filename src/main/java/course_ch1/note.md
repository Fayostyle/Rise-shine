#初级班第一节

## 时间复杂度
评价一个算法流程的好坏，先看时间复杂度的指标，然后分析样本数据下的实际运行时间，也就是常数项时间。

常数时间的操作:一个操作如果和数据量没有关系，每次都是固定时间内完成的操作。
例如：数组寻址操作，加减乘除，位运算操作

## 排序算法
### 冒泡排序BubbleSort
时间复杂度O(N^2)，额外空间复杂度O(1)

每一次排序，将最大的放到最后，接下来每次只需要循环遍历到end-1

###插入排序SelectSort
时间复杂度O(N^2)，额外空间复杂度O(1)

两层for循环，外层从第一个数开始遍历，内层从该数后面一个数字开始遍历，在内层中每个数都和当前minIndex比较，取值较小的数的下标为新的minIndex，然后与当前i值交换。

#### 注意
```java
swap(a, b){
a = a + b;
b = a - b;
a = a - b;
}
```

这段代码是没问题的，但是如果是根据数组下标进行交换，则会出现当最终不需要交换但是执行到swap时，出现置0的情况
如：
```java
swap(int[] arr, int i, int j){
arr[i] = arr[i] + arr[j];
arr[j] = arr[i] - arr[j];
arr[i] = arr[i] - arr[j];
```
如果i和j相等，假设为3，则会在第二行出现arr[3]=0,3下标处则直接变为3，没有达到交换到效果。
此种异或方式同样存在问题
```java
swap(int[] arr, int i, int j){
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```
###插入排序InsertSort 
时间复杂度O(N^2)，额外空间复杂度O(1)
最好情况O(N)，最坏情况O(N^2)，当时间复杂度受样本原始状况影响时，一律按最差情况估计。

### 对数器
0. 有一个你想要测的方法a，
1. 实现一个绝对正确但是复杂度不好的方法b，
2. 实现一个随机样本产生器
3. 实现比对的方法
4. 把方法a和方法b比对很多次来验证方法a是否正确。
5. 如果有一个样本使得比对出错，打印样本分析是哪个方法出
错
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经
正确。

###剖析递归行为和递归行为时间复杂度的估算

####一个递归行为的例子 Code002
递归就是将大问题分解为一个一个小问题，其中同时使用到分治的思想

要求：在整个数组中找到最大值

1. 分解小问题，携带分治思想：左边的最大值leftMax，右边的最大值rightMax，这两个中间最大的值，
即为整个数组最大值。从中间分为两部分，分别求出左右最大值，比较二者
2. 左边和右边又可以继续分为两部分，直到“终止条件（递归调用中必然需要终止条件）”
，只有一个数的时候，不可以再分为两部分，即l == r的时候。

master公式的使用:用来估计递归行为时间复杂度

T(N) = a*T(n/b) + O(n^d)

T(N):样本量为N的时候算法时间复杂度

a：将总的样本规模分解后，子规模的执行次数

n/b：每个子规模中的样本个数。n个样本被分为b个子样本进行求解。
1) log(b,a) > d -> 复杂度为O(N^log(b,a))
2) log(b,a) = d -> 复杂度为O(N^d * logN)
3) log(b,a) < d -> 复杂度为O(N^d)

master公式只适用于子问题规模相等的情况，并且使用master公式时，
只需要从代码层面看将总的问题分为了几个子问题，而不用考虑子问题继续分解为子问题


代入Code002

T(N) = 2*(n/2) + O(1),即为T(N) = 2*(n/2) + O(n^0);
所以Code002的时间复杂度为O(n *log(1,1)) = O(n)

###MergeSort归并排序
时间复杂度O(N*logN)，额外空间复杂度O(N)

T(N) = 2*(n/2) + O(N),即为T(N) = 2*(n/2) + O(n^1);

所以归并排序时间复杂度为O(n ^ 1 *log(1,1)) = O(n * logn)



### 小和问题 Code003
在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组
的小和。

例子：

[1,3,4,2,5]

1左边比1小的数，没有；

3左边比3小的数，1；

4左边比4小的数，1、3；

2左边比2小的数，1；

5左边比5小的数，1、3、4、2；

所以小和为1+1+3+1+1+3+4+2=16

使用归并排序的思想，在每次merge的过程中将sum累加起来，即为结果。

### 逆序对 Code004
在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

仍然利用归并排序的思想，在merge的过程中，比较左右数的大小，满足题意则打印。

### 快速排序QuickSort
时间复杂度O(N*logN)，额外空间复杂度O(logN)

####引子1 AND 引子2 Code005 
引子1：给定一个数组arr，和一个数num，请把小于等于num的数放在数
   组的左边，大于num的数放在数组的右边。 

假设数组为0到N-1，初始p指向-1，代表小于等于区域，开始遍历数组，
如果当前数小于等于num，当前数与p+1小于等于区域后一位交换，并且小于等于区域向左扩张
一位，即p++，index++ 遍历到下一个数。 如果当前数大于num，不做任何操作，遍历到下一个数。

引子2：荷兰国旗问题。给定一个数组arr，和一个数num，请把小于num的数放在数组的
           左边，等于num的数放在数组的中间，大于num的数放在数组的
           右边。
           
假设数组为0到N-1，初始p指向-1，代表小于区域，p2指向N，代表大于区域。开始遍历数组，
如果当前数小于等于num，当前数与p1+1等于区域后一位交换，并且小于区域向左扩张
一位，即p++， index++ 遍历到下一个数。如果当前数大于num，与p2-1大于区域前一位数交换，并且大于区域向右扩张一位，
即p2--，下一轮循环仍然遍历当前index的数。如果当前数与num相等，index++ 直接遍历下一个数。



